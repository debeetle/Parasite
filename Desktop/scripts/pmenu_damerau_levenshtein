#!/usr/bin/env python3
import argparse
import curses
import curses.ascii
import io
import os
import shlex
import shutil
import signal
import subprocess
import sys

__version__ = "0.3.3"

def get_args():
    parser = argparse.ArgumentParser(
        usage="pipe newline-separated menu items to stdin and/or pass them as positional arguments"
    )
    parser.add_argument("item", nargs="*", help="the menu item text")
    parser.add_argument(
        "-c",
        "--command",
        help="the shell command which output will populate the menu items on every keystroke ({} will be replaced by the current input text)",
    )
    parser.add_argument("-p", "--prompt", help="the prompt text")
    args = parser.parse_args()
    if args.prompt is None:
        args.prompt = "> "
    return args

def get_input_items():
    input_items = []
    if not sys.stdin.isatty():
        stdin = io.TextIOWrapper(sys.stdin.buffer, "utf8", "replace")
        input_items += stdin.read().splitlines()
    input_items += args.item
    input_items = filter(None, input_items)
    return list(input_items)

def get_command_items():
    if not args.command:
        return []
    command_argument = shlex.quote(query_text)
    command = args.command.replace("{}", command_argument)
    try:
        command_output = subprocess.check_output(
            command, shell=True, stderr=subprocess.DEVNULL
        )
        command_output = command_output.decode("utf8", "replace")
        command_items = command_output.splitlines()
        command_items = filter(None, command_items)
        return list(command_items)
    except subprocess.CalledProcessError:
        return []

def redirect_stdio(func):
    try:
        prev_stdin = os.dup(0)
        prev_stdout = os.dup(1)
        stdin = open("/dev/tty")
        stdout = open("/dev/tty", "w")
        os.dup2(stdin.fileno(), 0)
        os.dup2(stdout.fileno(), 1)
        return func()
    finally:
        os.dup2(prev_stdin, 0)
        os.dup2(prev_stdout, 1)

def curses_wrapper(func):
    if "ESCDELAY" not in os.environ:
        os.environ["ESCDELAY"] = "0"
    try:
        screen = curses.initscr()
        curses.noecho()
        curses.cbreak()
        screen.keypad(True)
        return func(screen)
    finally:
        if "screen" in locals():
            screen.keypad(False)
            curses.echo()
            try:
                curses.nocbreak()
            except curses.error:
                pass
            curses.endwin()

def damerau_levenshtein(s1, s2):
    d = {}
    lenstr1 = len(s1)
    lenstr2 = len(s2)
    for i in range(-1, lenstr1 + 1):
        d[(i, -1)] = i + 1
    for j in range(-1, lenstr2 + 1):
        d[(-1, j)] = j + 1

    for i in range(lenstr1):
        for j in range(lenstr2):
            cost = 0 if s1[i] == s2[j] else 1
            d[(i, j)] = min(
                d[(i - 1, j)] + 1,      # deletion
                d[(i, j - 1)] + 1,      # insertion
                d[(i - 1, j - 1)] + cost  # substitution
            )
            if i and j and s1[i] == s2[j - 1] and s1[i - 1] == s2[j]:
                d[(i, j)] = min(d[(i, j)], d[(i - 2, j - 2)] + cost)  # transposition
    return d[(lenstr1 - 1, lenstr2 - 1)]

def get_filtered_items():
    if not query_text:
        return input_items + get_command_items()

    scored = []
    for item in input_items:
        dist = damerau_levenshtein(query_text.lower(), item.lower())
        scored.append((item, dist))
    scored.sort(key=lambda x: x[1])
    filtered_items = [item for item, score in scored]
    filtered_items += get_command_items()
    return filtered_items

def redraw(screen):
    try:
        screen.erase()
        items = filtered_items[: curses.LINES - 1]
        for i, item in enumerate(items):
            item_attr = curses.A_REVERSE if i == selection_index else curses.A_NORMAL
            screen.insstr(i + 1, 0, item[: curses.COLS - 1], item_attr)
        top_line_text = args.prompt + query_text
        top_line_offset = len(top_line_text) - (curses.COLS - 1)
        if top_line_offset < 0:
            top_line_offset = 0
        screen.addstr(0, 0, top_line_text[top_line_offset:])
        screen.refresh()
    except curses.error:
        pass

def main(screen):
    global selection_index, filtered_items, query_text
    selection_index = 0

    def on_sigwinch(*args):
        columns, lines = shutil.get_terminal_size()
        curses.resizeterm(lines, columns)
        redraw(screen)

    signal.signal(signal.SIGWINCH, on_sigwinch)

    while True:
        filtered_items = get_filtered_items()
        redraw(screen)
        try:
            char = screen.get_wch()
        except KeyboardInterrupt:
            return
        except curses.error:
            continue
        char_code = isinstance(char, str) and ord(char)

        if char_code in (curses.ascii.ESC, curses.ascii.BEL):
            return
        elif char_code == curses.ascii.EOT:
            return query_text
        elif (
            char_code in (curses.ascii.BS, curses.ascii.DEL)
            or char == curses.KEY_BACKSPACE
        ):
            query_text = query_text[:-1]
        elif char_code == curses.ascii.TAB:
            if filtered_items:
                query_text = filtered_items[selection_index]
        elif char_code == curses.ascii.NL:
            if filtered_items:
                return filtered_items[selection_index]
            else:
                return query_text
        elif char_code == curses.ascii.NAK:
            query_text = ""
        elif char_code == curses.ascii.ETB:
            query_text = re.sub(r"\\w*[^\\w]*$", "", query_text)
        elif isinstance(char, str) and not curses.ascii.isctrl(char):
            query_text += char

        selection_index = 0

if __name__ == "__main__":
    args = get_args()
    query_text = ""
    input_items = get_input_items()
    result = redirect_stdio(lambda: curses_wrapper(main))
    if not result:
        sys.exit(130)
    print(result)
